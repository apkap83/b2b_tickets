/**
 * Security Vulnerability Prevention Tests
 * 
 * Tests for preventing common security vulnerabilities including:
 * - SQL Injection attacks
 * - Cross-Site Scripting (XSS)
 * - CSRF attacks
 * - File upload security
 * - Input validation bypass
 * - Information disclosure
 */

import { SecurityTestUtils } from './security-test-utils';

// Mock database pool
const mockPgB2Bpool = {
  query: jest.fn(),
  connect: jest.fn(),
};

jest.mock('@b2b-tickets/db-access', () => ({
  pgB2Bpool: mockPgB2Bpool,
}));

const mockLogger = {
  debug: jest.fn(),
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
};

describe('Security Vulnerability Prevention Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('SQL Injection Prevention', () => {
    it('should prevent SQL injection in user queries', async () => {
      const sqlInjectionPayloads = SecurityTestUtils.getSqlInjectionPayloads();

      const safeUserQuery = async (username: string) => {
        // SAFE: Using parameterized queries
        const query = 'SELECT user_id, username FROM users WHERE username = $1';
        const params = [username];

        try {
          const result = await mockPgB2Bpool.query(query, params);
          return result.rows;
        } catch (error) {
          mockLogger.error('Database query error', { error: (error as Error).message });
          throw new Error('Database error');
        }
      };

      const unsafeUserQuery = async (username: string) => {
        // UNSAFE: String concatenation (vulnerable to SQL injection)
        const query = `SELECT user_id, username FROM users WHERE username = '${username}'`;

        // Detect potential SQL injection
        const sqlInjectionPatterns = [
          /('|(\\x27)|(\\x2D\\x2D)|(%27)|(%2D%2D))/i, // SQL comment patterns
          /((\%3D)|(=))[^\n]*((\%27)|(')|((\%3B)|(;)))/i, // SQL commands
          /union.*select/i, // UNION SELECT
          /insert.*into/i, // INSERT INTO
          /delete.*from/i, // DELETE FROM
          /update.*set/i, // UPDATE SET
          /drop.*table/i, // DROP TABLE
        ];

        const containsInjection = sqlInjectionPatterns.some(pattern => pattern.test(username));
        
        if (containsInjection) {
          mockLogger.error('SQL injection attempt detected', {
            suspiciousInput: username,
            query,
            blocked: true,
          });
          throw new Error('Invalid input detected');
        }

        try {
          const result = await mockPgB2Bpool.query(query);
          return result.rows;
        } catch (error) {
          mockLogger.error('Database query error', { error: (error as Error).message });
          throw new Error('Database error');
        }
      };

      // Mock successful query response
      mockPgB2Bpool.query.mockResolvedValue({
        rows: [{ user_id: 1, username: 'testuser' }]
      });

      // Safe query should work with normal input
      const safeResult = await safeUserQuery('normaluser');
      expect(safeResult).toHaveLength(1);

      // Test SQL injection payloads
      for (const payload of sqlInjectionPayloads) {
        // Safe query should handle injection attempts safely
        const safeResultWithPayload = await safeUserQuery(payload);
        expect(safeResultWithPayload).toBeDefined(); // Should not crash

        // Unsafe query should detect and block injection attempts
        await expect(unsafeUserQuery(payload)).rejects.toThrow('Invalid input detected');
      }

      // Verify SQL injection detection was logged
      expect(mockLogger.error).toHaveBeenCalledWith('SQL injection attempt detected', 
        expect.objectContaining({
          blocked: true,
        })
      );
    });

    it('should sanitize database inputs properly', async () => {
      const sanitizeInput = (input: string): string => {
        if (!input || typeof input !== 'string') {
          return '';
        }

        // Remove or escape dangerous characters
        let sanitized = input
          .replace(/[<>]/g, '') // Remove angle brackets
          .replace(/'/g, "''") // Escape single quotes for SQL
          .replace(/;/g, '') // Remove semicolons
          .replace(/--/g, '') // Remove SQL comments
          .replace(/\/\*/g, '') // Remove block comments start
          .replace(/\*\//g, '') // Remove block comments end
          .trim();

        // Limit length to prevent buffer overflow
        if (sanitized.length > 255) {
          sanitized = sanitized.substring(0, 255);
          mockLogger.warn('Input truncated due to length', {
            originalLength: input.length,
            truncatedLength: sanitized.length,
          });
        }

        return sanitized;
      };

      const performSafeQuery = async (userInput: string) => {
        const sanitizedInput = sanitizeInput(userInput);
        
        // Additional validation
        if (sanitizedInput !== userInput) {
          mockLogger.info('Input was sanitized', {
            original: userInput.substring(0, 50),
            sanitized: sanitizedInput.substring(0, 50),
          });
        }

        const query = 'SELECT * FROM tickets WHERE title = $1';
        const result = await mockPgB2Bpool.query(query, [sanitizedInput]);
        return result.rows;
      };

      mockPgB2Bpool.query.mockResolvedValue({ rows: [] });

      // Test various malicious inputs
      const maliciousInputs = [
        "'; DROP TABLE users; --",
        "<script>alert('xss')</script>",
        "test'; UPDATE users SET password='hacked' WHERE username='admin'--",
        "normal input", // Should not be modified
      ];

      for (const input of maliciousInputs) {
        const result = await performSafeQuery(input);
        expect(result).toBeDefined();
        
        if (input.includes("script") || input.includes("';")) {
          expect(mockLogger.info).toHaveBeenCalledWith('Input was sanitized', 
            expect.objectContaining({
              original: expect.stringContaining(input.substring(0, 20)),
            })
          );
        }
      }
    });
  });

  describe('Cross-Site Scripting (XSS) Prevention', () => {
    it('should prevent XSS in user inputs', async () => {
      const xssPayloads = SecurityTestUtils.getXssPayloads();

      const escapeHtml = (unsafe: string): string => {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;")
          .replace(/\//g, "&#x2F;")
          .replace(/javascript:/gi, "j&#97;vascript&#58;") // Escape javascript: protocol
          .replace(/on\w+=/gi, (match) => match.replace(/=/g, '&#61;')); // Escape event handlers
      };

      const validateAndEscapeUserInput = (input: string, fieldName: string) => {
        // Detect XSS patterns
        const xssPatterns = [
          /<script/i,
          /javascript:/i,
          /on\w+\s*=/i, // Event handlers like onclick, onload
          /<iframe/i,
          /<object/i,
          /<embed/i,
          /<link/i,
          /<meta/i,
          /expression\s*\(/i, // CSS expressions
        ];

        const containsXss = xssPatterns.some(pattern => pattern.test(input));
        
        if (containsXss) {
          mockLogger.warn('Potential XSS attempt detected', {
            fieldName,
            suspiciousInput: input.substring(0, 100),
            patterns: xssPatterns.filter(p => p.test(input)).map(p => p.source),
          });
        }

        // Escape HTML regardless
        const escaped = escapeHtml(input);
        
        if (escaped !== input) {
          mockLogger.debug('Input HTML escaped', {
            fieldName,
            original: input.substring(0, 50),
            escaped: escaped.substring(0, 50),
          });
        }

        return escaped;
      };

      // Test XSS payloads
      for (const payload of xssPayloads) {
        const escaped = validateAndEscapeUserInput(payload, 'test_field');
        
        // Verify dangerous patterns are escaped
        expect(escaped).not.toContain('<script>');
        expect(escaped).not.toContain('javascript:');
        expect(escaped).not.toContain('onerror=');
        
        // Should contain escaped equivalents
        if (payload.includes('<script>')) {
          expect(escaped).toContain('&lt;script&gt;');
        }
      }

      // Verify XSS detection was logged
      expect(mockLogger.warn).toHaveBeenCalledWith('Potential XSS attempt detected', 
        expect.objectContaining({
          fieldName: 'test_field',
          patterns: expect.arrayContaining([expect.any(String)]),
        })
      );
    });

    it('should implement Content Security Policy (CSP) validation', async () => {
      const validateCSPCompliance = (content: string, allowedSources: string[] = []) => {
        const cspViolations: string[] = [];

        // Check for inline scripts
        if (/<script(?![^>]*src=)[^>]*>/i.test(content)) {
          cspViolations.push('Inline script detected');
        }

        // Check for inline styles
        if (/<style[^>]*>/i.test(content) || /style\s*=/i.test(content)) {
          cspViolations.push('Inline style detected');
        }

        // Check for javascript: URIs
        if (/javascript:/i.test(content)) {
          cspViolations.push('JavaScript URI detected');
        }

        // Check for data: URIs in dangerous contexts
        if (/data:.*?base64/i.test(content) && /<(script|object|embed)/i.test(content)) {
          cspViolations.push('Dangerous data URI detected');
        }

        // Check external sources against allowlist
        const externalSources = content.match(/src\s*=\s*["']([^"']+)["']/gi) || [];
        for (const source of externalSources) {
          const url = source.match(/src\s*=\s*["']([^"']+)["']/i)?.[1];
          if (url && !allowedSources.some(allowed => url.startsWith(allowed))) {
            cspViolations.push(`Unauthorized external source: ${url}`);
          }
        }

        if (cspViolations.length > 0) {
          mockLogger.error('CSP violations detected', {
            violations: cspViolations,
            content: content.substring(0, 200),
          });
          return { compliant: false, violations: cspViolations };
        }

        return { compliant: true, violations: [] };
      };

      // Test CSP violations
      const violatingContent = [
        '<script>alert("xss")</script>',
        '<div style="background: url(javascript:alert(1))"></div>',
        '<script src="https://malicious.com/evil.js"></script>',
        '<img src="data:image/svg+xml;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==" />',
      ];

      const allowedSources = ['https://trusted.com', 'https://cdn.example.com'];

      for (const content of violatingContent) {
        const result = validateCSPCompliance(content, allowedSources);
        expect(result.compliant).toBe(false);
        expect(result.violations.length).toBeGreaterThan(0);
      }

      // Test compliant content
      const compliantContent = '<img src="https://trusted.com/image.jpg" alt="Safe image" />';
      const compliantResult = validateCSPCompliance(compliantContent, allowedSources);
      expect(compliantResult.compliant).toBe(true);
      expect(compliantResult.violations).toHaveLength(0);
    });
  });

  describe('File Upload Security', () => {
    it('should validate file types and prevent malicious uploads', async () => {
      const validateFileUpload = (file: any) => {
        const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx', '.txt'];
        const allowedMimeTypes = [
          'image/jpeg',
          'image/png', 
          'image/gif',
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          'text/plain'
        ];
        const maxSize = 10 * 1024 * 1024; // 10MB

        const errors: string[] = [];

        // Check file extension
        const extension = file.filename?.toLowerCase().split('.').pop();
        if (!extension || !allowedExtensions.includes(`.${extension}`)) {
          errors.push(`File extension '${extension}' not allowed`);
        }

        // Check MIME type
        if (!allowedMimeTypes.includes(file.mimetype)) {
          errors.push(`MIME type '${file.mimetype}' not allowed`);
        }

        // Check file size
        if (file.size > maxSize) {
          errors.push(`File size ${file.size} exceeds maximum ${maxSize}`);
        }

        // Check for path traversal
        if (file.filename?.includes('../') || file.filename?.includes('..\\')) {
          errors.push('Path traversal detected in filename');
          mockLogger.error('Path traversal attack in file upload', {
            filename: file.filename,
            suspiciousActivity: true,
          });
        }

        // Check for executable extensions (double extension attack)
        const executableExtensions = ['.exe', '.bat', '.sh', '.php', '.asp', '.jsp', '.js'];
        const fullFilename = file.filename?.toLowerCase() || '';
        
        for (const execExt of executableExtensions) {
          if (fullFilename.includes(execExt)) {
            errors.push(`Potentially executable file detected: ${execExt}`);
            mockLogger.warn('Executable file upload attempt', {
              filename: file.filename,
              detectedExtension: execExt,
            });
            break;
          }
        }

        return {
          valid: errors.length === 0,
          errors,
        };
      };

      // Test safe files
      const safeFile = SecurityTestUtils.createMockFileUpload(false);
      const safeResult = validateFileUpload(safeFile);
      expect(safeResult.valid).toBe(true);
      expect(safeResult.errors).toHaveLength(0);

      // Test malicious files
      const maliciousFiles = [
        SecurityTestUtils.createMockFileUpload(true), // Path traversal
        { filename: 'virus.exe', mimetype: 'application/octet-stream', size: 1000 },
        { filename: 'script.php', mimetype: 'application/x-php', size: 1000 },
        { filename: 'image.jpg.exe', mimetype: 'image/jpeg', size: 1000 }, // Double extension
        { filename: 'huge.txt', mimetype: 'text/plain', size: 50 * 1024 * 1024 }, // Too large
      ];

      for (const maliciousFile of maliciousFiles) {
        const result = validateFileUpload(maliciousFile);
        expect(result.valid).toBe(false);
        expect(result.errors.length).toBeGreaterThan(0);
      }

      expect(mockLogger.error).toHaveBeenCalled();
      expect(mockLogger.warn).toHaveBeenCalled();
    });

    it('should scan file contents for malicious patterns', async () => {
      const scanFileContent = (fileBuffer: Buffer, filename: string) => {
        const content = fileBuffer.toString('utf8');
        const threats: string[] = [];

        // Check for embedded scripts
        const scriptPatterns = [
          /<script/i,
          /javascript:/i,
          /<\?php/i,
          /<%.*%>/,
          /exec\s*\(/i,
          /system\s*\(/i,
          /shell_exec/i,
          /passthru/i,
        ];

        for (const pattern of scriptPatterns) {
          if (pattern.test(content)) {
            threats.push(`Suspicious script pattern detected: ${pattern.source}`);
          }
        }

        // Check for suspicious file headers (magic bytes)
        const magicBytes = fileBuffer.slice(0, 8);
        const magicString = magicBytes.toString('hex');

        // Common executable magic bytes
        const executableMagics = [
          '4d5a', // PE executable (MZ)
          '7f454c46', // ELF executable
          'cafebabe', // Java class file
        ];

        for (const magic of executableMagics) {
          if (magicString.toLowerCase().startsWith(magic)) {
            threats.push(`Executable file detected by magic bytes: ${magic}`);
            mockLogger.error('Executable file disguised as document', {
              filename,
              magicBytes: magicString,
              suspiciousActivity: true,
            });
          }
        }

        // Check for embedded URLs to suspicious domains
        const urlPattern = /https?:\/\/([a-zA-Z0-9.-]+)/g;
        const urls = content.match(urlPattern) || [];
        const suspiciousDomains = ['.tk', '.ml', '.ga', 'bit.ly', 'tinyurl.com', 'suspicious.com'];
        
        for (const url of urls) {
          for (const suspiciousDomain of suspiciousDomains) {
            if (url.includes(suspiciousDomain)) {
              threats.push(`Suspicious URL detected: ${url}`);
              mockLogger.warn('Suspicious URL in uploaded file', {
                filename,
                url,
              });
            }
          }
        }

        return {
          safe: threats.length === 0,
          threats,
        };
      };

      // Test safe content
      const safeContent = Buffer.from('This is a normal document with safe content.');
      const safeResult = scanFileContent(safeContent, 'safe.txt');
      expect(safeResult.safe).toBe(true);
      expect(safeResult.threats).toHaveLength(0);

      // Test malicious content
      const maliciousContent = Buffer.from('<script>alert("xss")</script>Visit http://suspicious.com/malware');
      const maliciousResult = scanFileContent(maliciousContent, 'malicious.txt');
      expect(maliciousResult.safe).toBe(false);
      expect(maliciousResult.threats.length).toBeGreaterThan(0);

      // Test executable disguised as text
      const executableContent = Buffer.from([0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00]); // MZ header
      const execResult = scanFileContent(executableContent, 'fake.txt');
      expect(execResult.safe).toBe(false);
      expect(execResult.threats.some(t => t.includes('Executable file detected'))).toBe(true);

      expect(mockLogger.error).toHaveBeenCalledWith('Executable file disguised as document', 
        expect.objectContaining({
          magicBytes: expect.stringContaining('4d5a'),
        })
      );
    });
  });

  describe('Information Disclosure Prevention', () => {
    it('should prevent sensitive information leakage in error messages', async () => {
      const sanitizeErrorMessage = (error: Error, isProduction: boolean = true) => {
        const sensitivePatterns = [
          /password/i,
          /secret/i,
          /key/i,
          /token/i,
          /hash/i,
          /salt/i,
          /connection string/i,
          /database/i,
          /sql/i,
          /file (path|not found)/i,
          /stack trace/i,
          /internal server/i,
          /\/[a-z]+\/[a-z\/]+/i, // Unix-style file paths
        ];

        let sanitizedMessage = error.message;

        if (isProduction) {
          // In production, replace sensitive information with generic messages
          for (const pattern of sensitivePatterns) {
            if (pattern.test(sanitizedMessage)) {
              mockLogger.warn('Sensitive information detected in error message', {
                originalLength: error.message.length,
                pattern: pattern.source,
              });
              return 'An error occurred while processing your request.';
            }
          }
        }

        // Remove absolute file paths
        sanitizedMessage = sanitizedMessage.replace(/[A-Za-z]:\\[^\\]+\\?/g, '[PATH]');
        sanitizedMessage = sanitizedMessage.replace(/\/[^\/\s]+\/[^\/\s]+/g, '[PATH]');

        // Remove specific database errors
        sanitizedMessage = sanitizedMessage.replace(/table "[^"]*"/gi, 'table [TABLE]');
        sanitizedMessage = sanitizedMessage.replace(/column "[^"]*"/gi, 'column [COLUMN]');

        return sanitizedMessage;
      };

      // Test sensitive error messages
      const sensitiveErrors = [
        new Error('Database connection failed: password authentication failed for user "admin"'),
        new Error('JWT secret key "super-secret-key-123" is invalid'),
        new Error('File not found at /home/user/sensitive/config.txt'),
        new Error('SQL error: table "user_passwords" does not exist'),
        new Error('Internal server error in authentication module'),
      ];

      for (const error of sensitiveErrors) {
        const sanitized = sanitizeErrorMessage(error, true);
        
        // Should return generic message for sensitive errors
        expect(sanitized).toBe('An error occurred while processing your request.');
        expect(SecurityTestUtils.validateSecureErrorMessage(sanitized)).toBe(true);
      }

      // Test non-sensitive error
      const safeError = new Error('Invalid input format');
      const sanitizedSafe = sanitizeErrorMessage(safeError, true);
      expect(sanitizedSafe).toBe('Invalid input format');

      expect(mockLogger.warn).toHaveBeenCalledWith('Sensitive information detected in error message', 
        expect.objectContaining({
          pattern: expect.any(String),
        })
      );
    });

    it('should prevent user enumeration through response timing', async () => {
      const consistentResponseTime = 200; // Minimum response time in ms

      const simulateUserLogin = async (username: string, password: string) => {
        const startTime = Date.now();
        let userExists = false;
        let passwordCorrect = false;

        // Simulate database lookup
        if (username === 'validuser') {
          userExists = true;
          // Simulate password hashing comparison (expensive operation)
          await new Promise(resolve => setTimeout(resolve, 50));
          passwordCorrect = password === 'correctpassword';
        }

        // Calculate remaining time to reach consistent response time
        const elapsed = Date.now() - startTime;
        const remainingTime = Math.max(0, consistentResponseTime - elapsed);
        
        if (remainingTime > 0) {
          await new Promise(resolve => setTimeout(resolve, remainingTime));
        }

        const totalTime = Date.now() - startTime;

        if (!userExists || !passwordCorrect) {
          // Always return the same error message regardless of whether user exists
          throw new Error('Invalid credentials');
        }

        return { 
          success: true, 
          responseTime: totalTime,
        };
      };

      // Test timing consistency
      const scenarios = [
        ['validuser', 'correctpassword'], // Valid user, correct password
        ['validuser', 'wrongpassword'],   // Valid user, wrong password  
        ['invaliduser', 'anypassword'],   // Invalid user
      ];

      const responseTimes: number[] = [];

      for (const [username, password] of scenarios) {
        const startTime = Date.now();
        
        try {
          const result = await simulateUserLogin(username, password);
          responseTimes.push(result.responseTime);
        } catch (error) {
          const responseTime = Date.now() - startTime;
          responseTimes.push(responseTime);
          expect((error as Error).message).toBe('Invalid credentials');
        }
      }

      // Verify all response times are roughly consistent
      const minTime = Math.min(...responseTimes);
      const maxTime = Math.max(...responseTimes);
      const timeDifference = maxTime - minTime;

      // Allow some variance but ensure it's not significant enough for timing attacks
      expect(timeDifference).toBeLessThan(50); // Less than 50ms difference
      expect(minTime).toBeGreaterThanOrEqual(consistentResponseTime - 10); // Close to target time
    });

    it('should prevent information disclosure through HTTP headers', async () => {
      const sanitizeHttpHeaders = (headers: Record<string, string>) => {
        const sensitiveHeaders = [
          'server', // Don't reveal server technology
          'x-powered-by', // Don't reveal framework
          'x-aspnet-version', // Don't reveal ASP.NET version
          'x-runtime', // Don't reveal runtime info
        ];

        const securityHeaders = {
          'x-content-type-options': 'nosniff',
          'x-frame-options': 'DENY',
          'x-xss-protection': '1; mode=block',
          'strict-transport-security': 'max-age=31536000; includeSubDomains',
          'content-security-policy': "default-src 'self'",
          'referrer-policy': 'strict-origin-when-cross-origin',
        };

        const sanitized = { ...headers };

        // Remove sensitive headers
        for (const sensitiveHeader of sensitiveHeaders) {
          if (sanitized[sensitiveHeader]) {
            mockLogger.debug('Removing sensitive header', {
              header: sensitiveHeader,
              value: sanitized[sensitiveHeader],
            });
            delete sanitized[sensitiveHeader];
          }
        }

        // Add security headers
        Object.assign(sanitized, securityHeaders);

        return sanitized;
      };

      // Test headers with sensitive information
      const originalHeaders = {
        'server': 'Apache/2.4.41 (Ubuntu)',
        'x-powered-by': 'Express',
        'x-runtime': 'Node.js v18.17.0',
        'content-type': 'application/json',
        'cache-control': 'no-cache',
      };

      const sanitizedHeaders = sanitizeHttpHeaders(originalHeaders);

      // Sensitive headers should be removed
      expect(sanitizedHeaders['server']).toBeUndefined();
      expect(sanitizedHeaders['x-powered-by']).toBeUndefined();
      expect(sanitizedHeaders['x-runtime']).toBeUndefined();

      // Security headers should be added
      expect(sanitizedHeaders['x-content-type-options']).toBe('nosniff');
      expect(sanitizedHeaders['x-frame-options']).toBe('DENY');
      expect(sanitizedHeaders['strict-transport-security']).toContain('max-age=31536000');

      // Non-sensitive headers should remain
      expect(sanitizedHeaders['content-type']).toBe('application/json');
      expect(sanitizedHeaders['cache-control']).toBe('no-cache');

      expect(mockLogger.debug).toHaveBeenCalledWith('Removing sensitive header', 
        expect.objectContaining({
          header: expect.any(String),
        })
      );
    });
  });

  describe('Rate Limiting and DoS Prevention', () => {
    it('should implement comprehensive rate limiting', async () => {
      const mockRedisClient = SecurityTestUtils.createMockRedisForRateLimit();

      const implementRateLimit = async (
        clientIP: string, 
        endpoint: string, 
        windowMs: number = 60000, 
        maxRequests: number = 100
      ) => {
        const key = `rate_limit:${clientIP}:${endpoint}`;
        const current = await mockRedisClient.get(key);
        const currentCount = current ? parseInt(current) : 0;

        if (currentCount >= maxRequests) {
          mockLogger.warn('Rate limit exceeded', {
            clientIP,
            endpoint,
            currentCount: currentCount + 1,
            maxRequests,
            windowMs,
          });
          throw new Error('Rate limit exceeded');
        }

        // Increment counter
        await mockRedisClient.incr(key);
        
        // Set expiration on first request
        if (currentCount === 0) {
          await mockRedisClient.expire(key, Math.floor(windowMs / 1000));
        }

        return {
          allowed: true,
          remaining: maxRequests - currentCount - 1,
          resetTime: Date.now() + windowMs,
        };
      };

      // Mock Redis responses for rate limiting test
      mockRedisClient.get.mockResolvedValueOnce('100'); // Already at limit
      mockRedisClient.incr.mockResolvedValue(101);

      // Should block when limit exceeded
      await expect(implementRateLimit('192.168.1.100', '/api/login', 60000, 100))
        .rejects.toThrow('Rate limit exceeded');

      expect(mockLogger.warn).toHaveBeenCalledWith('Rate limit exceeded', {
        clientIP: '192.168.1.100',
        endpoint: '/api/login',
        currentCount: 101,
        maxRequests: 100,
        windowMs: 60000,
      });

      // Should allow when under limit
      mockRedisClient.get.mockResolvedValueOnce('50');
      const result = await implementRateLimit('192.168.1.101', '/api/data', 60000, 100);
      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(49);
    });
  });
});